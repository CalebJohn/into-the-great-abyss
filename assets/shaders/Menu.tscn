[gd_scene load_steps=3 format=1]

[sub_resource type="CanvasItemShader" id=1]

_code = { "fragment":"//uniform time = TIME\nuniform vec2 mouse = vec2(0, 0);\nuniform vec2 resolution = vec2(1024, 600);\n\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p*11.5, vec2(43.232, 75.876)))*45246.32957);\n}\n\n//Based off of iq\'s described here: http://www.iquilezles.org/www/articles/voronoilin\nfloat voronoi(vec2 p, float s) {\n  vec2 n = floor(p);\n  vec2 f = fract(p);\n  float md = 5.0;\n  vec2 m = vec2(0.0);\n//Repeat enough times\n//-1, -1\n      vec2 g = vec2(-1, -1);\n\t  vec2 hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      vec2 o = hash2*vec2(s, s);\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      vec2 r = g + o - f;\n      float d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//-1, 0\n      g = vec2(-1.0, 0.0);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//-1, 1\n      g = vec2(-1, 1);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//0, -1\n      g = vec2(0, -1);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//0, 0\n      g = vec2(0, 0);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//0, 1\n      g = vec2(0, 1);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//1, -1\n      g = vec2(1, -1);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//1, 0\n      g = vec2(1, 0);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n//1, 1\n      g = vec2(1, 1);\n\t  hash2 = fract(vec2(sin(dot(n+g, vec2(123.4, 748.6))), sin(dot(n+g, vec2(547.3, 659.3))))*5232.85324);\n      o = hash2*s;\n      o = vec2(0.5, 0.5) + vec2(0.5, 0.5) * vec2(sin(0.64 + 5.038*o.x), sin(0.64 + 5.038*o.y));\n      r = g + o - f;\n      d = dot(r, r);\n      if (d<md) {\n        md = d;\n        m = n+g+o;\n      }\n\treturn md;\n}\n\n//adjust uv\nvec2 uv = SCREEN_UV;\n//uv.x /= resolution.x;\n//uv.y /= resolution.y;\nuv.x *= (resolution.x / resolution.y);\n\nfloat sh = 0.5+0.5*sin(TIME);//mouse.y;\n\n  //sun position\nvec2 sun = vec2(0.5*(resolution.x / resolution.y), -0.21+1.42*sh);\n  //calculate sky gradient\n     //stars\nvec3 nightsky = mix(vec3(0.2, 0.2, 0.6), vec3(1.0, 1.0, 0.8), (0.8*smoothstep(0.9992, 1.0, 1.0-voronoi(uv*10.0, 16.0))*(1.0-sh)*(1.0-sh)));\nnightsky = mix(nightsky, vec3(1.0, 1.0, 0.8), (0.2+0.8*smoothstep(0.996, 1.0, 1.0-voronoi(uv*vec2(35.0), 16.0))*(1.0-sh)*(1.0-sh)));\nnightsky = mix(nightsky, vec3(1.0, 1.0, 0.8), (0.8*smoothstep(0.99, 1.0, hash(uv))*(1.0-sh)*(1.0-sh)));\nvec3 zenith = mix(nightsky, vec3(0.4, 0.6, 1.0), sh);\nvec3 azimuth = mix(vec3(1.0, 0.4, 0.4), vec3(0.75, 0.9, 1.0), sh);\nvec3 skygrad = mix(azimuth, zenith, smoothstep(0.0, 0.7+0.2*(cos((1.0-sh)*3.14159*3.0)), uv.y));\n\n  //add the sun\nvec3 col = mix(vec3(1.0, 0.2+0.8*sh, 0.0), skygrad, smoothstep(0.2, 0.203, length(sun-uv)));\n\n  // make some thin wispy clouds\n\n\n  // terrain\n//ov will be replaced with an inlined voronoi\nfloat h = 0.0;//ov(vec2(uv.x, 1.0));\n//fake fbm loop//unpacked the loop here\nvec2 fuv = vec2(uv.x, 1.0);\nh+= voronoi(fuv*1.0, 1.0)*0.4;\nh+= voronoi(fuv*2.0, 1.0)*0.2;\nh+= voronoi(fuv*4.0, 1.0)*0.1;\nh+= voronoi(fuv*8.0, 1.0)*0.05;\nh+= voronoi(fuv*16.0, 1.0)*0.025;\nh+= voronoi(fuv*32.0, 1.0)*0.0125;\n\ncol = mix(col, vec3(0.3+0.65*sh, 0.3+0.2*sh, 0.2+0.1*sh), smoothstep(0.028, 0.03, h-uv.y));\n\nCOLOR = vec4(col, 1.0);\n", "fragment_ofs":0, "light":"", "light_ofs":0, "vertex":"", "vertex_ofs":0 }

[sub_resource type="CanvasItemMaterial" id=2]

shader/shader = SubResource( 1 )
shader/shading_mode = 0
shader_param/mouse = Vector2( 0, 0 )
shader_param/resolution = Vector2( 1024, 600 )

[node name="Root" type="Control"]

focus/ignore_mouse = false
focus/stop_mouse = true
size_flags/horizontal = 2
size_flags/vertical = 2
margin/left = 0.0
margin/top = 0.0
margin/right = 40.0
margin/bottom = 40.0

[node name="Menu" type="Control" parent="."]

focus/ignore_mouse = false
focus/stop_mouse = true
size_flags/horizontal = 2
size_flags/vertical = 2
margin/left = 0.0
margin/top = 0.0
margin/right = 1024.0
margin/bottom = 600.0

[node name="Background" type="Polygon2D" parent="Menu"]

material/material = SubResource( 2 )
polygon = Vector2Array( 0, 0, 1024, 0, 1024, 600, 0, 600 )
uv = Vector2Array( 0, 0, 1, 0, 1, 1, 0, 1 )
color = Color( 1, 1, 1, 1 )
vertex_colors = ColorArray(  )
offset = Vector2( 0, 0 )
texture/texture = null
texture/offset = Vector2( 0, 0 )
texture/scale = Vector2( 1, 1 )
texture/rotation = 0.0
invert/enable = false
invert/border = 100.0


